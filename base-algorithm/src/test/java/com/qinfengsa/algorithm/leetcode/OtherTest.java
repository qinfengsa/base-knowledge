package com.qinfengsa.algorithm.leetcode;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;

/**
 * 其他
 *
 * @author: qinfengsa
 * @date: 2019/5/30 07:55
 */
@Slf4j
public class OtherTest {

    @Test
    public void hammingWeight() {
        int n = -3;
        int result = hammingWeight(n);
        log.debug("result:{}", result);
    }

    /**
     * 位1的个数 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。
     *
     * <p>示例 1：
     *
     * <p>输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011
     * 中，共有三位为 '1'。 示例 2：
     *
     * <p>输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000
     * 中，共有一位为 '1'。 示例 3：
     *
     * <p>输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有
     * 31 位为 '1'。
     *
     * <p>提示：
     *
     * <p>请注意，在某些语言（如
     * Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在
     * Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
     *
     * <p>进阶: 如果多次调用这个函数，你将如何优化你的算法？
     *
     * @param n
     * @return
     */
    public int hammingWeight(int n) {
        int count = 0;
        /*while(n != 0 && n != -1) {
            log.debug("n:{}",n);
            count += n&1; //最后一位
            n>>=1; // -> n = n>>1 右移一位
        }*/

        /**
         * 汉明重量：二进制中1的个数 汉明距离：两个二进制中 位数不同的个数
         *
         * <p>汉明重量计算： n &= n - 1
         *
         * <p>这个操作对比当前操作位高的位没有影响，对低位则完全清零。
         *
         * <p>拿6（110）来做例子，
         *
         * <p>第一次 110&101=100，这次操作成功的把从低位起第一个1消掉了，同时计数器加1。
         *
         * <p>第二次100&011=000，同理又统计了高位的一个1，此时n已变为0，不需要再继续了，于是110中有2个1。
         */
        /**
         * 汉明距离计算：
         *
         * <p>先将两个数进行异或^（相同为0不同为1）运算 再将异或完的数 计算汉明重量，也就是计算有多少个不同的数， 计算共多少个1
         */
        while (n != 0) {
            n = n & (n - 1);
            log.debug("n:{}", n);
            count++;
        }
        return count;
    }

    @Test
    public void reverseBits() {
        int n = -3;
        int result = reverseBits(n);
        log.debug("result:{}", result);
    }

    /**
     * 颠倒二进制位 颠倒给定的 32 位无符号整数的二进制位。
     *
     * <p>示例 1：
     *
     * <p>输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串
     * 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为
     * 00111001011110000010100101000000。 示例 2：
     *
     * <p>输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串
     * 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为
     * 10101111110010110010011101101001。
     *
     * <p>提示：
     *
     * <p>请注意，在某些语言（如
     * Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在
     * Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
     *
     * <p>进阶: 如果多次调用这个函数，你将如何优化你的算法？
     *
     * @param n
     * @return
     */
    public int reverseBits(int n) {
        /** 将给定的二进制数,由低到高位逐个取出 然后通过位运算将其放置到反转后的位置. 将上述结果再次通过运算结合到一起 */
        int result = 0;
        for (int i = 0; i <= 32; i++) {
            // 1. 将给定的二进制数,由低到高位逐个取出
            // 1.1 右移 i 位,
            int tmp = n >> i;
            // 1.2  取有效位
            tmp = tmp & 1;
            // 2. 然后通过位运算将其放置到反转后的位置.
            tmp = tmp << (31 - i);
            // 3. 将上述结果再次通过运算结合到一起
            result |= tmp;
        }
        return result;
    }

    @Test
    public void leastInterval() {
        char[] tasks = {'A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'D', 'D'};
        int n = 2;
        int result = leastInterval(tasks, n);
        log.debug("result : {}", result);
    }

    /**
     * Task Scheduler 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，
     * 并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。
     *
     * <p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
     *
     * <p>你需要计算完成所有任务所需要的最短时间。
     *
     * <p>示例 1：
     *
     * <p>输入: tasks = ["A","A","A","B","B","B"], n = 2 输出: 8 执行顺序: A -> B -> (待命) -> A -> B -> (待命)
     * -> A -> B. 注：
     *
     * <p>任务的总个数为 [1, 10000]。 n 的取值范围为 [0, 100]。
     *
     * @param tasks
     * @param n
     * @return
     */
    public int leastInterval(char[] tasks, int n) {
        // 计算每个任务出现的次数
        int[] taskList = new int[26];
        for (char c : tasks) {
            int index = c - 'A';
            taskList[index]++;
        }
        // 找出出现次数最多的任务，假设出现次数为 max
        int max = 0;
        for (int num : taskList) {
            if (num > max) {
                max = num;
            }
        }
        // 计算出现次数为 max 的任务总数 lastCount，计算最终结果为 minTimes + lastCount
        int lastCount = 0;
        for (int num : taskList) {
            if (num == max) {
                lastCount++;
            }
        }
        // 计算至少需要的时间 (max - 1) * (n + 1)，记为 minTimes
        int result = (max - 1) * (n + 1) + lastCount;
        // 如果 result 比任务数少，取任务数
        int len = tasks.length;

        return result < len ? len : result;
    }

    @Test
    public void test1() {
        int val = 16;
        boolean a = (val & -val) == val;
        log.debug("a:{}", a);
    }
}
